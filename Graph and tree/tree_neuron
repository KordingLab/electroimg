
function [x,y,z,t,U,W,E_ground] = tree_neuron(path)
data = open(path);
n = data.neuron;
neuron_locations = n(:, 3:5);
Sim = SimElecRec;
initialization = [0,0,0,1];
swc_matrix = n(1:end, :);
T = 150;
dt = 1;
k = 2;
% Simulation
[all_index_amp_active, all_location_detections, index_location_amp_time] = ...
    Sim.simulation(initialization, swc_matrix, T, dt);
subtracks = Sim.subtracks(index_location_amp_time, k, 1);
D = index_location_amp_time(:,2:6);
P = n(1:end, 7);
S = subtracks(:, 5:end);

V = 1:size(index_location_amp_time, 1);
W = sparse(length(V), length(V));

% space time
x = ones(length(V),1);
x(index_location_amp_time(:,1)) = index_location_amp_time(:,2);

y = ones(length(V),1);
y(index_location_amp_time(:,1)) = index_location_amp_time(:,3);

z = ones(length(V),1);
z(index_location_amp_time(:,1)) = index_location_amp_time(:,4);

t = ones(length(V),1);
t(index_location_amp_time(:,1)) = index_location_amp_time(:,6);

% cost edges
for i = 1:size(S, 1)
    i1 = S(i,1);
    i2 = S(i, 2);
    W(i1, i2) = sqrt((x(i1)-x(i2))^2+(y(i1)-y(i2))^2+(z(i1)-z(i2))^2)+(t(i1)-t(i2))^2;
end

% cost for branching
U = Inf*ones(length(V),1);
for i=V
    if length(find(P==i))==2
        U(i) = 1;
    end
end
% ground truth
E_ground = sparse(length(V), length(V));
for i=V(2:end)
    E_ground(P(i), i) = 1;
end
end
